import { Atom, Bond, Molecule } from '../types/molecular';
import { generateId } from './molecular';

export function parsePDB(pdbContent: string): Molecule | null {
  const lines = pdbContent.split('\n');
  const atoms: Atom[] = [];
  const bonds: Bond[] = [];
  const atomMap = new Map<number, Atom>(); // Map PDB atom serial to our Atom object

  let moleculeName = 'Untitled Molecule';

  lines.forEach(line => {
    if (line.startsWith('COMPND')) {
      moleculeName = line.substring(10).trim();
    } else if (line.startsWith('ATOM') || line.startsWith('HETATM')) {
      const serial = parseInt(line.substring(6, 11).trim());
      const element = line.substring(76, 78).trim();
      const x = parseFloat(line.substring(30, 38).trim());
      const y = parseFloat(line.substring(38, 46).trim());
      const z = parseFloat(line.substring(46, 54).trim());

      const atom: Atom = {
        id: generateId(),
        element: element,
        position: [x, y, z],
        color: '#CCCCCC', // Default color, can be updated later based on element data
        radius: 0.5, // Default radius, can be updated later based on element data
      };
      atoms.push(atom);
      atomMap.set(serial, atom);
    } else if (line.startsWith('CONECT')) {
      const atomSerial1 = parseInt(line.substring(6, 11).trim());
      const connectedSerials = line.substring(11).match(/\d{1,5}/g) || [];

      const atom1 = atomMap.get(atomSerial1);
      if (atom1) {
        connectedSerials.forEach(s => {
          const atomSerial2 = parseInt(s);
          const atom2 = atomMap.get(atomSerial2);
          if (atom2) {
            // Ensure bond is only added once (e.g., A-B, not B-A)
            const existingBond = bonds.some(bond =>
              (bond.atom1Id === atom1.id && bond.atom2Id === atom2.id) ||
              (bond.atom1Id === atom2.id && bond.atom2Id === atom1.id)
            );
            if (!existingBond) {
              const distance = Math.sqrt(
                Math.pow(atom1.position[0] - atom2.position[0], 2) +
                Math.pow(atom1.position[1] - atom2.position[1], 2) +
                Math.pow(atom1.position[2] - atom2.position[2], 2)
              );
              bonds.push({
                id: generateId(),
                atom1Id: atom1.id,
                atom2Id: atom2.id,
                bondType: 'single', // Default to single, can be refined with bond order detection
                length: distance,
              });
            }
          }
        });
      }
    }
  });

  if (atoms.length === 0) {
    return null;
  }

  return {
    id: generateId(),
    name: moleculeName,
    atoms,
    bonds,
  };
}

export function moleculeToPDB(molecule: Molecule): string {
  let pdbContent = `COMPND    ${molecule.name}\n`;
  pdbContent += `AUTHOR    Generated by MolecuJoint Lab\n`;

  let atomSerial = 1;
  const atomSerialMap = new Map<string, number>();

  molecule.atoms.forEach(atom => {
    atomSerialMap.set(atom.id, atomSerial);
    const x = atom.position[0].toFixed(3).padStart(8, ' ');
    const y = atom.position[1].toFixed(3).padStart(8, ' ');
    const z = atom.position[2].toFixed(3).padStart(8, ' ');
    const element = atom.element.padEnd(2, ' ');
    pdbContent += `ATOM  ${atomSerial.toString().padStart(5, ' ')}  ${atom.element.padEnd(3, ' ')} MOL A   1    ${x}${y}${z}  1.00  0.00          ${element}\n`;
    atomSerial++;
  });

  molecule.bonds.forEach(bond => {
    const serial1 = atomSerialMap.get(bond.atom1Id);
    const serial2 = atomSerialMap.get(bond.atom2Id);
    if (serial1 && serial2) {
      pdbContent += `CONECT${serial1.toString().padStart(5, ' ')}${serial2.toString().padStart(5, ' ')}\n`;
    }
  });

  pdbContent += `END\n`;

  return pdbContent;
}


